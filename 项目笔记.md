# 项目笔记

## 默认使用的mdns注册中心，无法调通的坑

默认使用的的mdns比consul方便不少，也需要注意，bash环境中不能有代理，如果设置了科学上网代理，会导致无法调通。

## 显示200OK但无数据显示

可能是没有设置数据类型。给前端返回数据是，要加header

w.Header().Set("Content-Type", application/json

## proto传输复杂对象

传输复杂对象时，如图片，可以将图片对象一步一步拆解成基本数据类型后，传输后，重新组装。

## 生成接口代码的命令

    protoc --proto_path=.:$GOPATH/src --go_out=plugins=grpc:. --micro_out=. proto/GetArea/GetArea.proto

## RPC调用和普通函数调用最大的区别（只能值传递）

RPC只能值传递，这在传递对象时一定要注意避免引用传递的问题，
A调用B，那么A要用实体对象来接受B返回的数据。B返回数据时，也一定要再要rsp中传递对应的值，如果rsp中是指针，则传入包含实体内容的指针过去。如果rsp中是值，则传入实体值进去。

**尤其使用注意点调用时，容易忽视值还是指针。不能用指针下的实体接收实体。而是用指针接收实体的指针。**

## 关于URL中的？：&

URL中的:a，a属于URL的一部分，通常用于URL末尾。本质是输入匹配后命名。可以通过ByName（a）得到他的值
？是分割URL和参数的，？后面的是一系列参数，注意参数可重名，即一个参数可对应多个值，所以解析这些参数出来通常是个切片。而不是直接的值。
&用来连接参数。

## 链接使用redis的代码段

```go

_ "github.com/astaxie/beego/cache/redis"
_ "github.com/gomodule/redigo/redis"

    // 读取redis链接配置
	redisConf := map[string]string{
		"key":      utils.G_server_name,
		"conn":     utils.G_redis_addr + ":" + utils.G_redis_port,
		"dbNum":    utils.G_redis_dbnum,
		"password": utils.G_redis_auth,
	}
	// 将map转换为json
	redisConfJSON, _ := json.Marshal(redisConf)
	// 开始链接redis
	bm, err := cache.NewCache("redis", string(redisConfJSON))
	if err != nil {
		beego.Info("缓存查询失败", err)
		rsp.Error = utils.RECODE_DBERR
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return err
	}

```

### redis中取数据

```go
	reply := bm.Get(uuid)
	if reply == nil {
		beego.Info("缓存查询结果为空")
		rsp.Error = utils.RECODE_NODATA
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return nil
	}
	str, _ := redis.String(reply, nil)
	if str != text {
		beego.Info("图片验证码错误", str, "?", text)
		rsp.Error = utils.RECODE_IMAGECDERR
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return nil
	}

```

## 忘记将micro改成grpc

运行起来竟然也没毛病，但是显示一些看不懂的信息。

## 缓存格式

```go
	bm.Put(sessionID+"user_id", user.Id, time.Second*3600)
	bm.Put(sessionID+"user_name", mobile, time.Second*3600)
	bm.Put(sessionID+"user_mobile", mobile, time.Second*3600)
```

## 获取并验证cookie

```go
// 从cookies中获取sessionID
	cookie, err := r.Cookie("userlogin")
	if err != nil || cookie.Value == "" {
		// 说明用户本没有登录，返回对应信息即可
		response := map[string]interface{}{
			"errno":  utils.RECODE_SESSIONERR,
			"errmsg": utils.RecodeText(utils.RECODE_SESSIONERR),
		}
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(response); err != nil {
			http.Error(w, err.Error(), 500)
			return
		}
		return
	}
```

## 设置cookies

```go
	newCookie := http.Cookie{
		Name:   "userlogin",
		Path:   "/",
		MaxAge: -1,
		Value:  "",
	}
	http.SetCookie(w, &newCookie)
	//返回给前端的数据
```

## 调用微服务

```go
	// 开始调用微服务
	service := grpc.NewService()
	service.Init()
	getUserInfoService := GETUSERINFO.NewGetUserInfoService("go.micro.srv.GetUserInfo", service.Client())
	rsp, err := getUserInfoService.CallGetUserInfo(context.TODO(), &GETUSERINFO.Request{
		SessionID: cookie.Value,
	})
	// 若发生错误
	if err != nil {
		beego.Info("RPC错误")
		http.Error(w, err.Error(), 500)
		return
	}
```

## 构造前端接受的数据结构

```go
	// 构造前端接受的data结构，接收rsp中的参数
	data := make(map[string]interface{})
	data["user_id"] = rsp.GetUserID()
	data["name"] = rsp.GetName()
	data["mobile"] = rsp.GetMobile()
	data["real_name"] = rsp.GetRealName()
	data["id_card"] = rsp.GetIDCard()
	data["avatar_url"] = utils.AddDomain2Url(rsp.GetAvatarUrl())
```

## 给前端返回数据的接口

```go

// 给前端返回数据
	response := map[string]interface{}{
		"errno":  rsp.Error,
		"errmsg": rsp.ErrMsg,
		"data":   data,
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, err.Error(), 500)
		return
	}
	return
```
##  微服务启动后的初始化操作


```go
	beego.Info("用户登录 PostSession api/v1.0/session")
	// 初始化回复
	rsp.Error = utils.RECODE_OK
	rsp.ErrMsg = utils.RecodeText(rsp.Error)
	// 获取请求参数
	mobile := req.GetMobile()
	password := req.GetPassword()
```



## 微服务验证sessionID，并得到id

```go 
// 验证sessionID，并得到id
reply := bm.Get(sessionID + "user_id")
	if reply == nil {
		beego.Info("缓存查询结果为空")
		rsp.Error = utils.RECODE_NODATA
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return nil
	}
	beego.Info(reply, reflect.TypeOf(reply))
	id, err := redis.Int(reply, nil)
	if err != nil {
		beego.Info("缓存数据类型错误", err)
		rsp.Error = utils.RECODE_DATAERR
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return err
	}

```
## 通过用户id查询用户所有数据

```go
// 通过用户id查询用户所有数据
	user := models.User{Id: id}
	o := orm.NewOrm()
	o.Read(&user)
	beego.Info(user)
```

## 获取客户端提交的json表单

```go
	// 获取客户端提交的json表单
	data := make(map[string]string)
	err := json.NewDecoder(r.Body).Decode(&data)
	if err != nil {
		beego.Info("表单解析失败", err)
		http.Error(w, err.Error(), 500)
		return
	}
```

## 获取URL中【:key】对应的value

假设url="/api/myurl:uuid"
实际访问地址：/api/myurl/1232-1232-34534-232
```go
	// 获取uuid
	uuid := ps.ByName("uuid")

```

## 获取URL中？后面的参数带的值

假设url="/api/myurl:uuid"
实际访问地址：/api/myurl/1232-1232-34534-232?id=123&name=lerix

```go
	text := r.URL.Query()["text"][0]
	uuid := r.URL.Query()["id"][0]
```