# 项目笔记

## 默认使用的mdns注册中心，无法调通的坑

默认使用的的mdns比consul方便不少，也需要注意，bash环境中不能有代理，如果设置了科学上网代理，会导致无法调通。

## 显示200OK但无数据显示

可能是没有设置数据类型。给前端返回数据是，要加header

w.Header().Set("Content-Type", application/json

## proto传输复杂对象

传输复杂对象时，如图片，可以将图片对象一步一步拆解成基本数据类型后，传输后，重新组装。

## 生成接口代码的命令

    protoc --proto_path=.:$GOPATH/src --go_out=plugins=grpc:. --micro_out=. proto/GetArea/GetArea.proto

## RPC调用和普通函数调用最大的区别（只能值传递）

RPC只能值传递，这在传递对象时一定要注意避免引用传递的问题，
A调用B，那么A要用实体对象来接受B返回的数据。B返回数据时，也一定要再要rsp中传递对应的值，如果rsp中是指针，则传入包含实体内容的指针过去。如果rsp中是值，则传入实体值进去。

**尤其使用注意点调用时，容易忽视值还是指针。不能用指针下的实体接收实体。而是用指针接收实体的指针。**

## 关于URL中的？：&

URL中的:a，a属于URL的一部分，通常用于URL末尾。本质是输入匹配后命名。可以通过ByName（a）得到他的值
？是分割URL和参数的，？后面的是一系列参数，注意参数可重名，即一个参数可对应多个值，所以解析这些参数出来通常是个切片。而不是直接的值。
&用来连接参数。

## 链接使用redis的代码段

```go

_ "github.com/astaxie/beego/cache/redis"
_ "github.com/gomodule/redigo/redis"
    
redisConf := map[string]string{
		"key":      utils.G_server_name,
		"conn":     utils.G_redis_addr + ":" + utils.G_redis_port,
		"dbNum":    utils.G_redis_dbnum,
		"password": utils.G_redis_auth,
	}
	// 将map转换为json
	redisConfJSON, _ := json.Marshal(redisConf)

	// 链接redis
	bm, err := cache.NewCache("redis", string(redisConfJSON))
	if err != nil {
		beego.Info("缓存查询失败", err)
		rsp.Error = utils.RECODE_DATAERR
		rsp.Errmsg = utils.RecodeText(rsp.Error)
		return err
	}

```