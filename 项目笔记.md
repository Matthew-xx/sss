# 项目笔记

## 默认使用的mdns注册中心，无法调通的坑

默认使用的的mdns比consul方便不少，也需要注意，bash环境中不能有代理，如果设置了科学上网代理，会导致无法调通。

## 显示200OK但无数据显示

可能是没有设置数据类型。给前端返回数据是，要加header

w.Header().Set("Content-Type", application/json

## proto传输复杂对象

传输复杂对象时，如图片，可以将图片对象一步一步拆解成基本数据类型后，传输后，重新组装。

## 生成接口代码的命令

    protoc --proto_path=.:$GOPATH/src --go_out=plugins=grpc:. --micro_out=. proto/GetArea/GetArea.proto

## RPC调用和普通函数调用最大的区别（只能值传递）

RPC只能值传递，这在传递对象时一定要注意避免引用传递的问题，
A调用B，那么A要用实体对象来接受B返回的数据。B返回数据时，也一定要再要rsp中传递对应的值，如果rsp中是指针，则传入包含实体内容的指针过去。如果rsp中是值，则传入实体值进去。

**尤其使用注意点调用时，容易忽视值还是指针。不能用指针下的实体接收实体。而是用指针接收实体的指针。**

## 关于URL中的？：&

URL中的:a，a属于URL的一部分，通常用于URL末尾。本质是输入匹配后命名。可以通过ByName（a）得到他的值
？是分割URL和参数的，？后面的是一系列参数，注意参数可重名，即一个参数可对应多个值，所以解析这些参数出来通常是个切片。而不是直接的值。
&用来连接参数。

## 链接使用redis的代码段

```go

_ "github.com/astaxie/beego/cache/redis"
_ "github.com/gomodule/redigo/redis"
    
redisConf := map[string]string{
		"key":      utils.G_server_name,
		"conn":     utils.G_redis_addr + ":" + utils.G_redis_port,
		"dbNum":    utils.G_redis_dbnum,
		"password": utils.G_redis_auth,
	}
	// 将map转换为json
	redisConfJSON, _ := json.Marshal(redisConf)

	// 链接redis
	bm, err := cache.NewCache("redis", string(redisConfJSON))
	if err != nil {
		beego.Info("缓存查询失败", err)
		rsp.Error = utils.RECODE_DBERR
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return err
	}

```

### redis中取数据

```go
	reply := bm.Get(uuid)
	if reply == nil {
		beego.Info("缓存查询结果为空")
		rsp.Error = utils.RECODE_NODATA
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return nil
	}
	str, _ := redis.String(reply, nil)
	if str != text {
		beego.Info("图片验证码错误", str, "?", text)
		rsp.Error = utils.RECODE_IMAGECDERR
		rsp.ErrMsg = utils.RecodeText(rsp.Error)
		return nil
	}

```

## 忘记将micro改成grpc

运行起来竟然也没毛病，但是显示一些看不懂的信息。

## 缓存格式

```go
	bm.Put(sessionID+"user_id", user.Id, time.Second*3600)
	bm.Put(sessionID+"user_name", mobile, time.Second*3600)
	bm.Put(sessionID+"user_mobile", mobile, time.Second*3600)
```

## 获取cookie

```go
// 从cookies中获取sessionID
	cookie, err := r.Cookie("userlogin")
	if err != nil || cookie.Value == "" {
		// 说明用户本没有登录，返回对应信息即可
		response := map[string]interface{}{
			"errno":  utils.RECODE_SESSIONERR,
			"errmsg": utils.RecodeText(utils.RECODE_SESSIONERR),
		}
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(response); err != nil {
			http.Error(w, err.Error(), 500)
			return
		}
		return
	}
```

## 设置cookies

```go
	newCookie := http.Cookie{
		Name:   "userlogin",
		Path:   "/",
		MaxAge: -1,
		Value:  "",
	}
	http.SetCookie(w, &newCookie)
	//返回给前端的数据
```